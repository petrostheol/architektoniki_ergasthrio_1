#Petros Theologou Alexandros Barboutis

##System:
1. CPU: Minor 
2. Frequency: 1000000000000
3. Caches: 64
4. Memory: 2283336

##config.ini:
type=MinorCPU
clk_gate_max=1000000000000
block_size=64
mem_ranges=0:2147483648

##config.json: 
"type": "MinorCPU",
"clk_gate_max": 1000000000000,
"block_size": 64,
"mem_ranges": ["0:2147483648"],

##Diffrentcpumodes:
SimpeCPU:

The SimpleCPU is a purely functional, in-order model that is suited for cases where a detailed model is not necessary. This can include warm-up periods, client systems that are driving a host, or just testing to make sure a program works.
It has recently been re-written to support the new memory system, and is now broken up into three classes: 
1. BaseSimpleCPU
2. AtomicSimpleCPU
3. TimingSimpleCPU

O3CPU:


TraceCPU:

The Trace CPU model plays back elastic traces, which are dependency and timing annotated traces generated by the Elastic Trace Probe attached to the O3 CPU model. The focus of the Trace CPU model is to achieve memory-system (cache-hierarchy, interconnects and main memory) performance exploration in a fast and reasonably accurate way instead of using the detailed but slow O3 CPU model. The traces have been developed for single-threaded benchmarks simulating in both SE and FS mode. They have been correlated for 15 memory-sensitive SPEC 2006 benchmarks and a handful of HPC proxy apps by interfacing the Trace CPU with classic memory system and varying cache design parameters and DRAM memory type. In general, elastic traces can be ported to other simulation environments.

Minor CPU Model:

Minor is an in-order processor model with a fixed pipeline but configurable data structures and execute behaviour. It is intended to be used to model processors with strict in-order execution behaviour and allows visualisation of an instruction’s position in the pipeline through the MinorTrace/minorview.py format/tool. The intention is to provide a framework for micro-architecturally correlating the model with a particular, chosen processor with similar capabilities.

##TimingSimpleCPU:
1. CPU:	TimingSimpleCPU
2. Frequency: 1000000000000
3. Caches: 64
4. Memory: 704704

##MinorCPU: 
1. CPU: MinorCPU
2. Frequency: 1000000000000
3. Caches: 64
4. Memory: 705988

##Different Frequency:
###TimingSimpleCPU:
1. CPU:	TimingSimpleCPU
2. Frequency: 1000000000000
3. Caches: 64
4. Memory: 704708

###MinorCPU:
1. CPU:	MinorCPU
2. Frequency: 1000000000000
3. Caches: 64
4. Memory: 705984

##Διαφορές
Τρέχοντας τα δύο προγράμματα και μετά απά σύγκριση των χρόνων που έκανε κάθε επεξεργαστής για να τρέξει το τελευταίο πρόγραμμα παρητηρήσαμε ότι πάντα ο MinorCPU ήταν αρκετά γρηγορότερος από τον TimingSimpleCPU. Αφού μελετήσαμε την πρακτικότητα του κάθε επεξεργαστή φθάσαμε στο συμπέρασμα οτι ο TimingSimpleCPU εφόσον έχει σχεδιαστεί περισσότερο για να τεστάρουμε εάν τρέχει ένα πρόγραμμα η γενικά το simulation θεωρήσαμε ότι θα πρέπει να αντιστοιχεί σε έναν πολύ απλό επεξεργαστή. Αντιθέτως ο MinorCPU αναφέρεται ότι έχει σχεδιαστεί έτσι ώστε το μοντέλο να σχετίζεται με ένα συγκεκριμένο πραγματικό επεξεργαστή δηλαδή να ανταποκρίνεται άμεσα στην πραγματικότητα. Επομένως καταλήξαμε στο συμπέρασμα ότι εφόσον ο MinorCPU ανταποκρίνεται με σημερινούς προηγμένους και πολύπλοκους επεξεργαστές ίσως για αυτό είναι συγκριτικά γρηγορότερος από τον TimingSimpleCPU. Αυτό επίσης επαληθεύεται από το γεγονός ότι όταν βάλαμε την συχνότητα μνήμης DDR4 που είναι η πιο προηγμένη σήμερα βελτιώνει αντιστοίχως σε ένα μικρό βαθμό και τους δύο επεξεργαστές. Παρακάτω αναγράφονται οι χρόνοι λειτουργίας:

1. MinorCPU: 38505000
2. MinorCPU DDR4_16x4: 37638000

1. TimingSimpleCPU: 49431000
2. TimingSimpleCPU DDR4_16x4: 49264000

